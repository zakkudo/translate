/**
 * Helper class to make working with translations enjoyable.
 *
 * <p>
 * <a href="https://travis-ci.org/zakkudo/translator">
 *     <img src="https://travis-ci.org/zakkudo/translator.svg?branch=master"
 *          alt="Build Status" /></a>
 * <a href="https://coveralls.io/github/zakkudo/translator?branch=master">
 *     <img src="https://coveralls.io/repos/github/zakkudo/translator/badge.svg?branch=master"
 *          alt="Coverage Status" /></a>
 * <a href="https://snyk.io/test/github/zakkudo/translator">
 *     <img src="https://snyk.io/test/github/zakkudo/translator/badge.svg"
 *          alt="Known Vulnerabilities"
 *          data-canonical-src="https://snyk.io/test/github/zakkudo/translator"
 *          style="max-width:100%;" /></a>
 * </p>
 *
 * Why use this?
 *
 * - Load arbitrary localizations with little fuss
 * - Incrementally load localizations for use with dynamic imports
 * - Keys are the translation strings itself, simplifying fallbacks and coding
 *
 * Install with:
 *
 * ```console
 * yarn add @zakkudo/translator
 * ```
 *
 * Also consider `@zakkudo/translate-webpack-plugin` or
 * `@zakkudo/translation-static-analyzer` for generating translation
 * templates that this library reads instead of writing them manually.
 * This library works very similar to `y18n` since it's a thin layer on
 * top of it to make it more appropriate for the web.
 *
 * @example <caption>Use the translations with a @zakkudo/translator</caption>
 * import Translator from '@zakkudo/translator';
 * import localization = from './src/.locales/ja.json'; //Generated by the analyzer
 *
 * const translator = new Translator();
 * translator.mergeLocalization('ja', localization); //Incrementally merge the localization
 * translator.setLocale('ja'); //Tell the translator to use it
 *
 * const translated = translator.__('I love fish'); //Translate!
 * const translated = translator.__n('There is a duck in the pond.', 'There are %d ducks in the pond', 3); //Translate!
 *
 * @module Translator
*/

import y18n from 'y18n';

/**
 * Class description
 */
class Translator {
    /**
     * Generate an instance of the translator.
    */
    constructor() {
        const instance = this.instance = y18n({
            updateFiles: false,
            locale: 'default',
            fallbackToLanguage: false,
        });

        instance.cache['default'] = {};
    }
    /**
     * Overwrites a specific localization with a new one.
     * @param {String} locale - The locale to overwrite
     * @param {Object} localization - The new localization mapping
     */
    setLocalization(locale, localization) {
        if (locale === 'default')  {
            throw new Error('Cannot overwrite the fallthrough locale.')
        }

        this.instance.cache[locale] = Object.assign({}, localization);
    }

    /**
     * Incrementally merges a localization into an existing one.
     * @param {String} locale - The locale to merge into
     * @param {Object} localization - The data to merge with the existing data.
     */
    mergeLocalization(locale, localization) {
        if (locale === 'default')  {
            throw new Error('Cannot merge into the fallthrough locale.')
        }

        this.instance.cache[locale] = Object.assign({}, this.instance.cache[locale], localization);
    }

    /**
     * Set the current locale. This will decide which localization is used.
     * @param {String} locale - A locale such as `ja_JP`, `en`, `es` or `default` to just passthrough
     */
    setLocale(locale) {
        this.instance.setLocale(locale);
    }

    /**
     * @return {String} The currently set locale or 'default' if none is set
     */
    getLocale() {
        return this.instance.getLocale();
    }

    /**
     * Get the mapping for a specific string using the currently set locale.  If the mapping does
     * not exist, the value is passed through.
     * @param {String} singular - The string to localize
     * @param {Array<String>} leftover - Leftover arguments to use for interpolation where `%d` or `%s` is used
     * @return {String} The localized string if it exists, otherwise the text is passed through as a fallback
     */
    __(singular, ...leftover) {
        const locale = this.getLocale();
        const cache = this.instance.cache;
        const localization = cache[locale];
        const fallback = singular

        localization[singular] = localization[singular] || fallback;

        return this.instance.__(singular, ...leftover);
    }

    /**
     * Translators a plural string.
     * @param {String} singular - The singular version of the string, such as `%s apple`
     * @param {String} plural - The plural version of the string, such as `%s apples`
     * @param {Number} quantity -  Count used to determine which version is used
     * @param {Array<String>} - Other interpolation arguments similar to the singular form of this function
     * @return {String} The localized string if it exists, otherwise the text is passed through as a fallback
     */
    __n(singular, plural, quantity, ...leftover) {
        const locale = this.getLocale();
        const cache = this.instance.cache;
        const localization = cache[locale];
        const fallback = {'one': singular, 'other': plural};

        if (localization[singular]) {
            if (!localization[singular].one) {
                localization[singular].one = singular;
            }

            if (!localization[singular].other) {
                localization[singular].other = plural;
            }
        }

        localization[singular] = localization[singular] || fallback;

        return this.instance.__n(singular, plural, quantity, ...leftover);
    }
}

export default Translator;
